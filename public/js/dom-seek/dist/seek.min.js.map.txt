{"version":3,"sources":["seek.js"],"names":["global","factory","define","amd","exports","module","mod","seek","this","iter","where","whatToShow","NodeFilter","SHOW_TEXT","Error","E_SHOW","count","node","referenceNode","predicates","isNumber","forward","backward","isText","E_WHERE","before","pointerBeforeReferenceNode","after","nextNode","textContent","length","previousNode","n","isNaN","parseInt","isFinite","nodeType","Node","TEXT_NODE","ref","compareDocumentPosition","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING"],"mappings":"CAAA,SAAWA,EAAQC,GACjB,GAAsB,kBAAXC,SAAyBA,OAAOC,IACzCD,QAAQ,UAAW,UAAWD,OACzB,IAAuB,mBAAZG,UAA6C,mBAAXC,QAClDJ,EAAQG,QAASC,YACZ,CACL,GAAIC,IACFF,WAEFH,GAAQK,EAAIF,QAASE,GACrBN,EAAOO,KAAOD,EAAIF,UAEnBI,KAAM,SAAUJ,EAASC,GAC1B,YATa,SAASE,GAAKE,EAAMC,GACjC,GAAID,EAAKE,aAAeC,WAAWC,UACjC,KAAM,IAAIC,OAAMC,EAGlB,IAAIC,GAAQ,EACRC,EAAOR,EAAKS,cACZC,EAAa,IAEjB,IAAIC,EAASV,GACXS,GACEE,QAAS,WAgBL,MAhBmBX,GAARM,GACfM,SAAU,WAkBN,MAlBYN,GAAQN,QAErB,CAAA,IAAIa,EAAOb,GAMhB,KAAM,IAAII,OAAMU,EALhBL,IACEE,QAAS,WAoBL,MApBWI,GAAOR,EAAMP,IAC5BY,SAAU,WAsBN,OAtBab,EAAKiB,4BAA8BC,EAAMV,EAAMP,KAMpE,KAAOS,EAAWE,WAA0C,QAA5BJ,EAAOR,EAAKmB,aAC1CZ,GAASC,EAAKY,YAAYC,MAG5B,MAAOX,EAAWG,YAA+C,QAAhCL,EAAOR,EAAKsB,iBAC3Cf,GAASC,EAAKY,YAAYC,MAG5B,OAAOd,GAIT,QAASI,GAASY,GAChB,OAAQC,MAAMC,SAASF,KAAOG,SAASH,GAIzC,QAAST,GAAON,GACd,MAAOA,GAAKmB,WAAaC,KAAKC,UAIhC,QAASb,GAAOc,EAAKtB,GACnB,MAAOA,GAAKuB,wBAAwBD,GAAOF,KAAKI,4BAIlD,QAASd,GAAMY,EAAKtB,GAClB,MAAOA,GAAKuB,wBAAwBD,GAAOF,KAAKK,4BAxChDrC,EAAOD,QAXeG,CAJxB,IAAMQ,GAAS,2DACTS,EAAU","file":"seek.min.js","sourcesContent":["const E_SHOW = 'Argument 1 of seek must use filter NodeFilter.SHOW_TEXT.';\nconst E_WHERE = 'Argument 2 of seek must be a number or a Text Node.';\n\n\nexport default function seek(iter, where) {\n  if (iter.whatToShow !== NodeFilter.SHOW_TEXT) {\n    throw new Error(E_SHOW);\n  }\n\n  let count = 0;\n  let node = iter.referenceNode;\n  let predicates = null;\n\n  if (isNumber(where)) {\n    predicates = {\n      forward: () => count < where,\n      backward: () => count > where\n    };\n  } else if (isText(where)) {\n    predicates = {\n      forward: () => before(node, where),\n      backward: () => !iter.pointerBeforeReferenceNode || after(node, where)\n    };\n  } else {\n    throw new Error(E_WHERE);\n  }\n\n  while (predicates.forward() && (node = iter.nextNode()) !== null) {\n    count += node.textContent.length;\n  }\n\n  while (predicates.backward() && (node = iter.previousNode()) !== null) {\n    count -= node.textContent.length;\n  }\n\n  return count;\n}\n\n\nfunction isNumber(n) {\n  return !isNaN(parseInt(n)) && isFinite(n);\n}\n\n\nfunction isText(node) {\n  return node.nodeType === Node.TEXT_NODE;\n}\n\n\nfunction before(ref, node) {\n  return node.compareDocumentPosition(ref) & Node.DOCUMENT_POSITION_PRECEDING;\n}\n\n\nfunction after(ref, node) {\n  return node.compareDocumentPosition(ref) & Node.DOCUMENT_POSITION_FOLLOWING;\n}\n"],"sourceRoot":"./"}