{"version":3,"sources":["TextPositionAnchor.js"],"names":["global","factory","define","amd","exports","module","require","mod","createNodeIterator","seek","TextPositionAnchor","this","_nodeIteratorShim","_domSeek","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","getFirstTextNode","node","nodeType","Node","TEXT_NODE","document","ownerDocument","walker","createTreeWalker","SHOW_TEXT","firstChild","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","_createNodeIterator","_seek","NodeFilter","root","start","end","undefined","Error","value","range","createRange","iter","count","remainder","pointerBeforeReferenceNode","setStart","referenceNode","nextNode","previousNode","setEnd","type","startNode","startContainer","startOffset","childNodes","textContent","endNode","endContainer","endOffset","selector","arguments"],"mappings":"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","file":"TextPositionAnchor.min.js","sourcesContent":["import createNodeIterator from 'node-iterator-shim';\nimport seek from 'dom-seek';\n\nconst SHOW_TEXT = NodeFilter.SHOW_TEXT;\n\n\nfunction getFirstTextNode(node) {\n  if (node.nodeType === Node.TEXT_NODE) return node;\n  let document = node.ownerDocument;\n  let walker = document.createTreeWalker(node, SHOW_TEXT, null, false);\n  return walker.firstChild();\n}\n\n\nexport default class TextPositionAnchor {\n  constructor(root, start, end) {\n    if (root === undefined) {\n      throw new Error('missing required parameter \"root\"');\n    }\n    if (start === undefined) {\n      throw new Error('missing required parameter \"start\"');\n    }\n    if (end === undefined) {\n      throw new Error('missing required parameter \"end\"');\n    }\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  static fromRange(root, range) {\n    if (root === undefined) {\n      throw new Error('missing required parameter \"root\"');\n    }\n    if (range === undefined) {\n      throw new Error('missing required parameter \"range\"');\n    }\n\n    let startNode = range.startContainer;\n    let startOffset = range.startOffset;\n\n    // Drill down to a text node if the range starts at the container boundary.\n    if (startNode.nodeType !== Node.TEXT_NODE) {\n      if (startOffset === startNode.childNodes.length) {\n        startNode = startNode.childNodes[startOffset - 1];\n        startNode = getFirstTextNode(startNode);\n        startOffset = startNode.textContent.length;\n      } else {\n        startNode = startNode.childNodes[startOffset];\n        startNode = getFirstTextNode(startNode);\n        startOffset = 0;\n      }\n    }\n\n    let endNode = range.endContainer;\n    let endOffset = range.endOffset;\n\n    // Drill down to a text node if the range ends at the container boundary.\n    if (endNode.nodeType !== Node.TEXT_NODE) {\n      if (endOffset === endNode.childNodes.length) {\n        endNode = endNode.childNodes[endOffset - 1];\n        endNode = getFirstTextNode(endNode);\n        endOffset = endNode.textContent.length;\n      } else {\n        endNode = endNode.childNodes[endOffset];\n        endNode = getFirstTextNode(endNode);\n        endOffset = 0;\n      }\n    }\n\n    let iter = createNodeIterator(root, SHOW_TEXT);\n    let start = seek(iter, startNode);\n    let end = start + seek(iter, endNode);\n\n    return new TextPositionAnchor(root, start + startOffset, end + endOffset);\n  }\n\n  static fromSelector(root, selector = {}) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  toRange() {\n    let root = this.root;\n    let document = root.ownerDocument;\n    let range = document.createRange();\n    let iter = createNodeIterator(root, SHOW_TEXT);\n\n    let {start, end} = this;\n    let count = seek(iter, start);\n    let remainder = start - count;\n\n    if (iter.pointerBeforeReferenceNode) {\n      range.setStart(iter.referenceNode, remainder);\n    } else {\n      // If the iterator advanced it will be left with its pointer after the\n      // reference node. The next node that is needed to create the range.\n      range.setStart(iter.nextNode(), remainder);\n      iter.previousNode();  // Rewind so as not to change the next result.\n    }\n\n    let length = (end - start) + remainder;\n    count = seek(iter, length);\n    remainder = length - count;\n\n    if (iter.pointerBeforeReferenceNode) {\n      range.setEnd(iter.referenceNode, remainder);\n    } else {\n      // Same as above, but no need to rewind.\n      range.setEnd(iter.nextNode(), remainder);\n    }\n\n    return range;\n  }\n\n  toSelector() {\n    return {\n      type: 'TextPositionSelector',\n      start: this.start,\n      end: this.end,\n    };\n  }\n}\n"],"sourceRoot":"./"}